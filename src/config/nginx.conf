# main (root) context

# we can tell how many processes should nginx spawn. Best practice is one per CPU (or auto)
worker_processes auto;

# custom pid file location
pid /var/run/nginx.pid;

# load a dynamic module
# load_module modules/ngx_http_image_filter_module.so; - for some reason relative path is not working
load_module /etc/nginx/modules/ngx_http_image_filter_module.so;

events {
  # we can configure max connections for each process.
  worker_connections 1024;
}

# http context
http {

  # Buffer size for POST submissions
  client_body_buffer_size 10k;
  client_max_body_size 8m;

  # Buffer size for header Headers
  client_header_buffer_size 1k;

  # Max time to receive client body headers/body
  client_body_timeout 12;
  client_header_timeout 12;

  # Max time to keep a connetion open for
  keepalive_timeout 15;

  # Max time for the clieht accept/receive a response
  send_timeout 10;

  # Skip buffering for static files
  sendfile on;

  # Optimise sendfile packets
  tcp_nopush on;


  # virtual server (we can have multiple server blocks listening on multiple ports)
  server {

    # port to listen on
    listen 80; 

    # domain name (can be ip address as well). add to hosts file to test
    server_name nginx-learn.com www.nginx-learn.com;

    # Files to display if only the domain name is specified in the address
    index index.php index.html index.htm;

    # include most used mime types so for example, style.css will be applied as a css file and not text
    include mime.types;

    # static folder to serve
    root /www;

    # location
    # location prioritizing
    # 1. Exact match
    # 2. Preferetial match
    # 3. Regex match (has same priority as preference match, whoever comes last wins
    # 4. Regular match 

    # prefix match
    location /greet {
      return 200 'Hello from /greet prefix match location';
    }

    # exact match
    location = /greet {
      return 200 'Hello from /greet exact match location';
    }

    # regex match - sensitive
    location ~ /greet[0-9] {
      return 200 'Hello from /greet[0-9] regex location';
    }

    # regex match - insensitive
    location ~* /greet[0-9] {
      return 200 'Hello from /greet[0-9] regex insensitive location';
    }

    # preferential match
    location ^~ /Greet {
      return 200 'Hello from /greet preferential match';
    }

    # variables
    # we have builtin variables and custom variables
  
    location /builtin_variables {
      return 200 'Host: $host\n Uri: $uri\n Query args: $args\nSingle query arg: $arg_name';
    }

    set $weekend 'No';
    if ($date_local ~ 'Saturday|Sunday') {
      set $weekend 'Yes';
    }
    
    location /custom_variables {
      return 200 'Is weekend: $weekend\nThe date is: $date_local';
    }

    # rewrites and redirects
    # redirects change browser url and run the corresponsing location block
    # rewrites do not! change browser url and run the corresponsing location block

    rewrite ^/user/(\w+) /greet/$1;
    # we can add an optional "last" paramfeter, to stop additional redirects. For example, "rewrite ^/user/(\w+) /greet/$1 last"

    location /redirect {
      return 307;
    }

    # try_files and named locations
    # try_files serves files according to the arguments provided, while fallback to the last argument if not found.
    # try_files can be put on the server level, or inside a location block/
    # for example, try_files Dockerfile tsconfig.json /redirect will always serve the dockerfile no matter what
    location / {
      try_files $uri $uri/ @not_found;
    }

    location @not_found {
      return 404 "This is a 404 error page (named location)";
    }

    # logs
    # we have access to the access.log and error.log files (see Dockerfile for details).
    # we can create custom log entries by using "access_log" and "error_log" directives. We can also disable logs for a particular route.

    location /secure {
      access_log /var/log/nginx/secure.access.log;
      return 200 "Write to custom log file";
    }

    location /nologs {
      access_log off;
      return 200 "disable logs in this route";
    }

    # inheritance
    # we can use inheritance and override directives.
    # For example, we can declare basic logging at the top, and then desable it for some particular routes.

    # passing php requests to php-fpm service (fastcgi).
    # fastcgi is a protocol about binary data exchange, in our case between the app and php service.
    # pass the data to php socket via fastcgi
    location ~ \.php$ {
      include fastcgi.conf;
      fastcgi_pass unix:/run/php/php7.1-fpm.sock;
    }

    # image filter dynamic module.
    # dynamic modules are added in runtime
    location = /nginx.png {
      image_filter rotate 180;
    }
  }

}